import { useContext, useRef, useLayoutEffect } from 'react';
import { useThree } from '@react-three/fiber';
import { useVisualElementContext } from '../../context/MotionContext/index.mjs';
import { MotionCanvasContext } from './MotionCanvasContext.mjs';
import { invariant } from 'hey-listen';
import { calcLength } from '../../projection/geometry/delta-calc.mjs';
import { getFrameData } from 'framesync';

var calcBoxSize = function (_a) {
    var x = _a.x, y = _a.y;
    return ({
        width: calcLength(x),
        height: calcLength(y),
    });
};
function useLayoutCamera(_a, updateCamera) {
    var _b = _a.makeDefault, makeDefault = _b === void 0 ? true : _b;
    var context = useContext(MotionCanvasContext);
    invariant(Boolean(context), "No MotionCanvas detected. Replace Canvas from @react-three/fiber with MotionCanvas from framer-motion.");
    var _c = context, setSize = _c.setSize, layoutCamera = _c.layoutCamera;
    var latestLayout = useRef(null);
    var advance = useThree(function (three) { return three.advance; });
    var set = useThree(function (three) { return three.set; });
    var camera = useThree(function (three) { return three.camera; });
    var size = useThree(function (three) { return three.size; });
    var gl = useThree(function (three) { return three.gl; });
    var parentVisualElement = useVisualElementContext();
    useLayoutEffect(function () {
        updateCamera(size);
        var projection = parentVisualElement === null || parentVisualElement === void 0 ? void 0 : parentVisualElement.projection;
        if (!projection)
            return;
        /**
         * When the projection of an element changes we want to update the camera
         * with the projected dimensions.
         */
        var removeProjectionUpdateListener = projection.addEventListener("projectionUpdate", function (newProjection) {
            // TODO: Removed to prevent iOS from crashing.
            // Perhaps a better apporach is to set with setSize
            // and then set to window native on animationComplete.
            // if (latestLayout.current) {
            //     const { x, y } = latestLayout.current
            //     const xRatio = calcLength(newProjection.x) / calcLength(x)
            //     const yRatio = calcLength(newProjection.y) / calcLength(y)
            //     gl.setPixelRatio(
            //         Math.max(xRatio, yRatio) * window.devicePixelRatio
            //     )
            // }
            updateCamera(calcBoxSize(newProjection));
            advance(getFrameData().timestamp);
        });
        /**
         * When the layout of an element changes we want to update the renderer
         * output to match the layout dimensions.
         */
        var removeLayoutMeasureListener = projection.addEventListener("measure", function (newLayout) {
            latestLayout.current = newLayout;
            var newSize = calcBoxSize(newLayout);
            gl.setSize(newSize.width, newSize.height);
            setSize(newSize);
        });
        /**
         * When a projection animation completes we want to update the camera to
         * match the recorded layout of the element.
         */
        var removeAnimationCompleteListener = projection.addEventListener("animationComplete", function () {
            var actual = (projection.layout || {}).actual;
            actual && updateCamera(calcBoxSize(actual));
        });
        return function () {
            removeProjectionUpdateListener();
            removeLayoutMeasureListener();
            removeAnimationCompleteListener();
        };
    }, []);
    useLayoutEffect(function () {
        var cam = layoutCamera.current;
        if (makeDefault && cam) {
            var oldCam_1 = camera;
            set(function () { return ({ camera: cam }); });
            return function () { return set(function () { return ({ camera: oldCam_1 }); }); };
        }
    }, [camera, layoutCamera, makeDefault, set]);
    return { size: size, camera: camera, cameraRef: layoutCamera };
}

export { useLayoutCamera };
